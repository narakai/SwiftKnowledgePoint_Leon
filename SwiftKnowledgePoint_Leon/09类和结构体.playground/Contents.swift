//: Playground - noun: a place where people can play

import UIKit

//swift不要求为自定义类和结构去创建独立的接口和实现文件，需要做的是在一个文件中定义一个类或者结构体，系统自动生成面向其它代码的外部接口
/*
 类和结构体对比，相同点：
 1.定义属性用于存储值
 2.定义方法用于提供功能
 3.定义下标操作使得可以通过下标语法来访问实例和所包含的值
 4.定义构造器用于生成初始化值
 5.通过扩展以增加默认实现的功能
 6.实现协议以提供某种标准功能
 
 类附加功能：
 1.继承允许一个类继承另一个类的特征
 2.类型转换允许在运行时检查和解释一个类实例的类型
 3.析构器允许一个类实例释放任何其所被分配的资源
 4.引用计数允许对一个类的多次引用
 
 结构体通过被复制的方式在代码中传递，不使用引用计数
 */

//定义语法，class和struct表示类和结构体
class SomeClass {
    var width = 0
    var height = 0
}
struct SomeStruct {
    var res = SomeClass()
    var inter = false
    var fram = 0
    var name: String?
}

//生成语法
let someclass = SomeClass()
var somestruct = SomeStruct()

//属性访问，实例名后紧跟属性名，通过.连接
someclass.width

//swift允许直接设置结构体属性的子属性
somestruct.name = "aa"

//结构体类型的成员逐一构造器
let som = SomeStruct(res: someclass, inter: true, fram: 11, name: "aaa")
//类实例没有默认的成员逐一构造器

//结构体和枚举是值类型。
//值类型：被赋予给一个变量、常量或者传递给一个函数时，其值会被拷贝
//所有基本类型：整数，浮点数，布尔值，字符串，数组，字典都是值类型，底层都是以结构体形式实现
//结构体和枚举也是值类型

//类是引用类型
//引用类型：在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝，引用的是已存在的实例本身而不是其拷贝

//恒等运算符，===   !==，监测两个常量和变量是否引用同一个实例

/*
 如下情况考虑结构体：
 1.该数据结构的主要目的是用来封装少量相关简单数据值
 2.有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用
 3.该数据结构体中存储的值类型属性，也应该被拷贝，而不是被引用
 4.该数据结构不需要去继承另一个既有的类型的属性或行为
 */

//swift中string,array,dic都是以结构体形式实现的，OC中，则均是类的形式实现，并非结构体。
//swift中的拷贝，只有在需要时才会拷贝，所以没有必要去回避赋值来优化性能，swift已经做好了优化

